<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.8.0/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/3.10.1/build/yui/yui-min.js"></script>
	<title>CloudKid Sound API v2.0.1 API Documentation : src/Sound.js</title>  
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><a href=""><img src="../assets/css/logo.png" title="CloudKid Sound API"></a></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Documentation for: 2.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>
		<ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
			<li><a href="#api-modules">Namespaces</a></li>
        </ul>
        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Sound.html">Sound</a></li>
            
                <li><a href="../classes/SoundContext.html">SoundContext</a></li>
            
                <li><a href="../classes/SoundInst.html">SoundInst</a></li>
            
                <li><a href="../classes/SoundListTask.html">SoundListTask</a></li>
            
                <li><a href="../classes/VOPlayer.html">VOPlayer</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/cloudkid.html">cloudkid</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
            <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <script>
	var name = src/Sound.js      
</script>
<h1 class="file-heading">File:Sound.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
*  @module cloudkid
*/
(function() {

	&quot;use strict&quot;;

	var OS = cloudkid.OS,
		MediaLoader = cloudkid.MediaLoader,
		LoadTask = cloudkid.LoadTask,
		Task = cloudkid.Task,
		TaskManager = cloudkid.TaskManager;

	/**
	*  Acts as a wrapper for SoundJS as well as adding lots of other functionality
	*  for managing sounds.
	*
	*  @class Sound
	*/
	var Sound = function()
	{
		this._sounds = {};
		this._fades = [];
		this._contexts = {};
		this._pool = [];
		this._update = this._update.bind(this);
		this._markLoaded = this._markLoaded.bind(this);
		/** 
		*  A copy of _playAfterLoad bound to this Sound instance.
		*  @property {function} _playAfterLoadBound
		*  @private
		*/
		this._playAfterLoadBound = this._playAfterLoad.bind(this);
	};
	
	var p = Sound.prototype = {};
	
	var _instance = null;
	
	/** 
	*  Dictionary of sound objects, containing configuration info and playback objects.
	*  @property {object} _sounds
	*  @private
	*/
	p._sounds = null;
	/** 
	
	*  Array of SoundInst objects that are being faded in or out.
	*  @property {Array} _fades
	*  @private
	*/
	p._fades = null;

	/**
	*  Array of SoundInst objects waiting to be used.
	*  @property {Array} _pool
	*  @private
	*/
	p._pool = null;

	/**
	*  The extension of the supported sound type that will be used.
	*  @property {string} supportedSound
	*  @public
	*/
	p.supportedSound = null;

	/**
	*  Dictionary of SoundContexts.
	*  @property {object} _contexts
	*  @private
	*/
	p._contexts = null;

	//sound states
	var UNLOADED = 0;
	var LOADING = 1;
	var LOADED = 2;

	var UPDATE_ALIAS = &quot;CKSOUND&quot;;

	/**
	*  A constant for telling Sound not to handle a sound with play(), but to
	*  return what SoundJS returns directly.
	*  @property {String} UNHANDLED
	*  @public
	*  @static
	*/
	Sound.UNHANDLED = &quot;unhandled&quot;;
	
	/**
	*	Initializes the Sound singleton.
	*	@method init
	*	@static
	*	@param {String} supportedSound The extension of the sound file type to use.
	*	@param {object} config An optional sound config object to load.
	*/
	Sound.init = function(supportedSound, config)
	{
		_instance = new Sound();
		_instance.supportedSound = supportedSound;
		if(config)
			_instance.loadConfig(config);
	};
	
	/**
	*  The singleton instance of Sound.
	*  @property {Sound} instance
	*  @public
	*  @static
	*/
	Object.defineProperty(Sound, &quot;instance&quot;,
	{
		get: function() { return _instance; }
	});
	
	/**
	*	Loads a config object.
	*	@method loadConfig
	*	@public
	*	@param {object} config The config to load.
	*	@param {String} defaultContext The optional sound context to load sounds into unless 
	*		otherwise specified. Sounds do not require a context.
	*/
	p.loadConfig = function(config, defaultContext)
	{
		if(!config)
		{
			Debug.warn(&quot;Warning - cloudkid.Sound was told to load a null config&quot;);
			return;
		}
		var list = config.soundManifest;
		var path = config.path;
		defaultContext = defaultContext || config.context;
		for(var i = 0, len = list.length; i &lt; len; ++i)
		{
			var s = list[i];
			var temp = this._sounds[s.id] = {
				id: s.id,
				src: path + s.src + this.supportedSound,
				volume: s.volume ? s.volume : 1,
				state: UNLOADED,
				playing: [],
				waitingToPlay: [],
				context: s.context || defaultContext,
				playAfterLoad: false,
				preloadCallback: null
			};
			if(temp.context)
			{
				if(!this._contexts[temp.context])
					this._contexts[temp.context] = new SoundContext(temp.context);
				this._contexts[temp.context].sounds.push(temp);
			}
		}
	};

	/**
	*	If a sound exists in the list of recognized sounds.
	*	@method exists
	*	@public
	*	@param {String} alias The alias of the sound to look for.
	*	@return {bool} true if the sound exists, false otherwise.
	*/
	p.exists = function(alias)
	{
		return !!this._sounds[alias];
	};

	/**
	*	If a sound is unloaded.
	*	@method isUnloaded
	*	@public
	*	@param {String} alias The alias of the sound to look for.
	*	@return {bool} true if the sound is unloaded, false if it is loaded, loading or does not exist.
	*/
	p.isUnloaded = function(alias)
	{
		return this._sounds[alias] ? this._sounds[alias].state == UNLOADED : false;
	};

	/**
	*	If a sound is loaded.
	*	@method isLoaded
	*	@public
	*	@param {String} alias The alias of the sound to look for.
	*	@return {bool} true if the sound is loaded, false if it is not loaded or does not exist.
	*/
	p.isLoaded = function(alias)
	{
		return this._sounds[alias] ? this._sounds[alias].state == LOADED : false;
	};

	/**
	*	If a sound is in the process of being loaded
	*	@method isLoading
	*	@public
	*	@param {String} alias The alias of the sound to look for.
	*	@return {bool} true if the sound is currently loading, false if it is loaded, unloaded, or does not exist.
	*/
	p.isLoading = function(alias)
	{
		return this._sounds[alias] ? this._sounds[alias].state == LOADING : false;
	};

	/**
	*	If a sound is playing.
	*	@method isPlaying
	*	@public
	*	@param {String} alias The alias of the sound to look for.
	*	@return {bool} true if the sound is currently playing or loading with an intent to play, false if it is not playing or does not exist.
	*/
	p.isPlaying = function(alias)
	{
		var sound = this._sounds[alias];
		return sound ? sound.playing.length + sound.waitingToPlay.length &gt; 0 : false;
	};

	/**
	*	Fades a sound from 0 to a specified volume.
	*	@method fadeIn
	*	@public
	*	@param {String|SoundInst} aliasOrInst The alias of the sound to fade the last played instance of, or an instance returned from play().
	*	@param {Number} duration The duration in milliseconds to fade for. The default is 500ms.
	*	@param {Number} targetVol The volume to fade to. The default is the sound&#x27;s default volume.
	*	@param {Number} startVol The volume to start from. The default is 0.
	*/
	p.fadeIn = function(aliasOrInst, duration, targetVol, startVol)
	{
		var sound, inst;
		if(typeof(aliasOrInst) == &quot;string&quot;)
		{
			sound = this._sounds[aliasOrInst];
			if(!sound) return;
			if(sound.playing.length)
				inst = sound.playing[sound.playing.length - 1];//fade the last played instance
		}
		else
		{
			inst = aliasOrInst;
			sound = this._sounds[inst.alias];
		}
		if(!inst || !inst._channel) return;
		inst._fTime = 0;
		inst._fDur = duration &gt; 0 ? duration : 500;
		var v = startVol &gt; 0 ? startVol : 0;
		inst._channel.setVolume(v);
		inst.curVol = inst._fStart = v;
		inst._fEnd = targetVol || sound.volume;
		if(this._fades.indexOf(inst) == -1)
		{
			this._fades.push(inst);
			if(this._fades.length == 1)
				OS.instance.addUpdateCallback(UPDATE_ALIAS, this._update);
		}
	};

	/**
	*	Fades a sound from the current volume to a specified volume. A sound that ends at 0 volume
	*	is stopped after the fade.
	*	@method fadeOut
	*	@public
	*	@param {String|SoundInst} aliasOrInst The alias of the sound to fade the last played instance of, or an instance returned from play().
	*	@param {Number} duration The duration in milliseconds to fade for. The default is 500ms.
	*	@param {Number} targetVol The volume to fade to. The default is 0.
	*	@param {Number} startVol The volume to fade from. The default is the current volume.
	*/
	p.fadeOut = function(aliasOrInst, duration, targetVol, startVol)
	{
		var sound, inst;
		if(typeof(aliasOrInst) == &quot;string&quot;)
		{
			sound = this._sounds[aliasOrInst];
			if(!sound) return;
			if(sound.playing.length)
				inst = sound.playing[sound.playing.length - 1];//fade the last played instance
		}
		else
		{
			inst = aliasOrInst;
			//sound = this._sounds[inst.alias];
		}
		if(!inst || !inst._channel) return;
		inst._fTime = 0;
		inst._fDur = duration &gt; 0 ? duration : 500;
		if(startVol &gt; 0)
		{
			inst._channel.setVolume(startVol);
			inst._fStart = startVol;
		}
		else
			inst._fStart = inst._channel.getVolume();
		inst.curVol = inst._fStart;
		inst._fEnd = targetVol || 0;
		if(this._fades.indexOf(inst) == -1)
		{
			this._fades.push(inst);
			if(this._fades.length == 1)
				OS.instance.addUpdateCallback(UPDATE_ALIAS, this._update);
		}
	};

	/** 
	*	The update call, used for fading sounds. This is bound to the instance of Sound
	*	@method _update
	*	@private
	*	@param {int} elapsed The time elapsed since the previous frame, in milliseconds.
	*/
	p._update = function(elapsed)
	{
		var fades = this._fades;
		var trim = 0;
		for(var i = fades.length - 1; i &gt;= 0; --i)
		{
			var inst = fades[i];
			if(inst.paused) continue;
			var time = inst._fTime += elapsed;
			if(time &gt;= inst._fDur)
			{
				if(inst._fEnd === 0)
				{
					var sound = this._sounds[inst.alias];
					sound.playing = sound.playing.splice(sound.playing.indexOf(inst), 1);
					this._stopInst(inst);
				}
				else
				{
					inst.curVol = inst._fEnd;
					inst.updateVolume();
				}
				++trim;
				var swapIndex = fades.length - trim;
				if(i != swapIndex)//don&#x27;t bother swapping if it is already last
				{
					fades[i] = fades[swapIndex];
				}
			}
			else
			{
				var lerp = time / inst._fDur;
				var vol;
				if(inst._fEnd &gt; inst._fStart)
					vol = inst._fStart + (inst._fEnd - inst._fStart) * lerp;
				else
					vol = inst._fEnd + (inst._fStart - inst._fEnd) * lerp;
				inst.curVol = vol;
				inst.updateVolume();
			}
		}
		fades.length = fades.length - trim;
		if(fades.length === 0)
			OS.instance.removeUpdateCallback(UPDATE_ALIAS);
	};
	
	/**
	*	Plays a sound.
	*	@method play
	*	@public
	*	@param {String} alias The alias of the sound to play.
	*	@param {function} completeCallback An optional function to call when the sound is finished. 
			Passing cloudkid.Sound.UNHANDLED results in cloudkid.Sound not handling the sound 
			and merely returning what SoundJS returns from its play() call.
	*	@param {function} startCallback An optional function to call when the sound starts playback.
			If the sound is loaded, this is called immediately, if not, it calls when the 
			sound is finished loading.
	*	@param {bool} interrupt If the sound should interrupt previous sounds (SoundJS parameter). Default is false.
	*	@param {Number} delay The delay to play the sound at in milliseconds(SoundJS parameter). Default is 0.
	*	@param {Number} offset The offset into the sound to play in milliseconds(SoundJS parameter). Default is 0.
	*	@param {int} loop How many times the sound should loop. Use -1 (or true) for infinite loops (SoundJS parameter).
			Default is no looping.
	*	@param {Number} volume The volume to play the sound at (0 to 1). Omit to use the default for the sound.
	*	@param {Number} pan The panning to start the sound at (-1 to 1). Default is centered (0).
	*	@return {SoundInst} An internal SoundInst object that can be used for fading in/out as well as 
			pausing and getting the sound&#x27;s current position.
	*/
	p.play = function (alias, completeCallback, startCallback, interrupt, delay, offset, loop, volume, pan)
	{
		if(loop === true)//Replace with correct infinite looping.
			loop = -1;
		//UNHANDLED is really for legacy code, like the StateManager and Cutscene libraries that are using the sound instance directly to synch animations
		if(completeCallback == Sound.UNHANDLED)//let calling code manage the SoundInstance - this is only allowed if the sound is already loaded
		{
			return createjs.Sound.play(alias, interrupt, delay, offset, loop, volume, pan);
		}

		var sound = this._sounds[alias];
		if(!sound)
		{
			Debug.error(&quot;cloudkid.Sound: sound &quot; + alias + &quot; not found!&quot;);
			if(completeCallback)
				completeCallback();
			return;
		}
		var state = sound.state;
		var inst, arr;
		volume = (typeof(volume) == &quot;number&quot; &amp;&amp; volume &gt; 0) ? volume : sound.volume;
		if(state == LOADED)
		{
			var channel = createjs.Sound.play(alias, interrupt, delay, offset, loop, volume, pan);
			//have Sound manage the playback of the sound
			
			if(!channel || channel.playState == createjs.Sound.PLAY_FAILED)
			{
				if(completeCallback)
					completeCallback();
				return null;
			}
			else
			{
				inst = this._getSoundInst(channel, sound.id);
				inst.curVol = volume;
				sound.playing.push(inst);
				inst._endCallback = completeCallback;
				inst.updateVolume();
				inst.length = channel.getDuration();
				inst._channel.addEventListener(&quot;complete&quot;, inst._endFunc);
				if(startCallback)
					setTimeout(startCallback, 0);
				return inst;
			}
		}
		else if(state == UNLOADED)
		{
			sound.state = LOADING;
			sound.playAfterLoad = true;
			inst = this._getSoundInst(null, sound.id);
			inst.curVol = volume;
			sound.waitingToPlay.push(inst);
			inst._endCallback = completeCallback;
			inst._startFunc = startCallback;
			if(inst._startParams)
			{
				arr = inst._startParams;
				arr[0] = interrupt;
				arr[1] = delay;
				arr[2] = offset;
				arr[3] = loop;
				arr[4] = pan;
			}
			else
				inst._startParams = [interrupt, delay, offset, loop, pan];
			MediaLoader.instance.load(
				sound.src, //url to load
				this._playAfterLoadBound,//complete callback
				null,//progress callback
				0,//priority
				sound//the sound object (contains properties for PreloadJS/SoundJS)
			);
			return inst;
		}
		else if(state == LOADING)
		{
			//tell the sound to play after loading
			sound.playAfterLoad = true;
			inst = this._getSoundInst(null, sound.id);
			inst.curVol = volume;
			sound.waitingToPlay.push(inst);
			inst._endCallback = completeCallback;
			inst._startFunc = startCallback;
			if(inst._startParams)
			{
				arr = inst._startParams;
				arr[0] = interrupt;
				arr[1] = delay;
				arr[2] = offset;
				arr[3] = loop;
				arr[4] = pan;
			}
			else
				inst._startParams = [interrupt, delay, offset, loop, pan];
			return inst;
		}
	};

	/**
	*	Gets a SoundInst, from the pool if available or maks a new one if not.
	*	@method _getSoundInst
	*	@private
	*	@param {createjs.SoundInstance} channel A createjs SoundInstance to initialize the object with.
	*	@param {String} id The alias of the sound that is going to be used.
	*	@return {SoundInst} The SoundInst that is ready to use.
	*/
	p._getSoundInst = function(channel, id)
	{
		var rtn;
		if(this._pool.length)
			rtn = this._pool.pop();
		else
		{
			rtn = new SoundInst();
			rtn._endFunc = this._onSoundComplete.bind(this, rtn);
		}
		rtn._channel = channel;
		rtn.alias = id;
		rtn.length = channel ? channel.getDuration() : 0;//set or reset this
		rtn.isValid = true;
		return rtn;
	};

	/**
	*	Plays a sound after it finishes loading.
	*	@method _playAfterload
	*	@private
	*	@param {String} alias The sound to play.
	*/
	p._playAfterLoad = function(result)
	{
		var alias = typeof result == &quot;string&quot; ? result : result.id;
		var sound = this._sounds[alias];
		sound.state = LOADED;
		
		//If the sound was stopped before it finished loading, then don&#x27;t play anything
		if(!sound.playAfterLoad) return;
		
		//Go through the list of sound instances that are waiting to start and start them
		var waiting = sound.waitingToPlay;
		for(var i = 0; i &lt; waiting.length; ++i)
		{
			var inst = waiting[i];
			var startParams = inst._startParams;
			var volume = inst.curVol;
			var channel = createjs.Sound.play(alias, startParams[0], startParams[1], startParams[2], startParams[3], volume, startParams[4]);

			if(!channel || channel.playState == createjs.Sound.PLAY_FAILED)
			{
				if(inst._endCallback)
					inst._endCallback();
				this._poolInst(inst);
			}
			else
			{
				sound.playing.push(inst);
				inst._channel = channel;
				inst.length = channel.getDuration();
				inst.updateVolume();
				channel.addEventListener(&quot;complete&quot;, inst._endFunc);
				if(inst._startFunc)
					inst._startFunc();
				if(inst.paused)//if the sound got paused while loading, then pause it
					channel.pause();
			}
		}
		waiting.length = 0;
	};
	
	/**
	*	The callback used for when a sound instance is complete.
	*	@method _onSoundComplete
	*	@private
	*	@param {SoundInst} inst The SoundInst that is complete.s
	*/
	p._onSoundComplete = function(inst)
	{
		inst._channel.removeEventListener(&quot;complete&quot;, inst._endFunc);
		var sound = this._sounds[inst.alias];
		sound.playing.splice(sound.playing.indexOf(inst), 1);
		var callback = inst._endCallback;
		this._poolInst(inst);
		if(callback)
			callback();
	};
	
	/**
	*	Stops all playing or loading instances of a given sound.
	*	@method stop
	*	@public
	*	@param {String} alias The alias of the sound to stop.
	*/
	p.stop = function(alias)
	{
		var s = this._sounds[alias];
		if(!s) return;
		if(s.playing.length)
			this._stopSound(s);
		else if(s.state == LOADING)
		{
			s.playAfterLoad = false;
			var waiting = s.waitingToPlay;
			for(var i = 0; i &lt; waiting.length; ++i)
			{
				var inst = waiting[i];
				/*if(inst._endCallback)
					inst._endCallback();*/
				this._poolInst(inst);
			}
			waiting.length = 0;
		}
	};
	
	/**
	*	Stops all playing SoundInsts for a sound.
	*	@method _stopSound
	*	@private
	*	@param {object} s The sound (from the _sounds dictionary) to stop.
	*/
	p._stopSound = function(s)
	{
		var arr = s.playing;
		for(var i = arr.length -1; i &gt;= 0; --i)
		{
			this._stopInst(arr[i]);
		}
		arr.length = 0;
	};
	
	/**
	*	Stops and repools a specific SoundInst.
	*	@method _stopInst
	*	@private
	*	@param {SoundInst} inst The SoundInst to stop.
	*/
	p._stopInst = function(inst)
	{
		inst._channel.removeEventListener(&quot;complete&quot;, inst._endFunc);
		inst._channel.stop();
		this._poolInst(inst);
	};
	
	/**
	*	Stops all sounds in a given context.
	*	@method stopContext
	*	@public
	*	@param {String} context The name of the context to stop.
	*/
	p.stopContext = function(context)
	{
		context = this._contexts[context];
		if(context)
		{
			var arr = context.sounds;
			for(var i = arr.length - 1; i &gt;= 0; --i)
			{
				var s = arr[i];
				if(s.playing.length)
					this._stopSound(s);
				else if(s.state == LOADING)
					s.playAfterLoad = false;
			}
		}
	};

	/**
	*	Pauses a specific sound.
	*	@method pauseSound
	*	@public
	*	@param {String} alias The alias of the sound to pause. 
	*		Internally, this can also be the object from the _sounds dictionary directly.
	*/
	p.pauseSound = function(alias)
	{
		var sound;
		if(typeof alias == &quot;string&quot;)
			sound = this._sounds[alias];
		else
			sound = alias;
		var arr = sound.playing;
		for(var i = arr.length - 1; i &gt;= 0; --i)
			arr[i].pause();
	};

	/**
	*	Unpauses a specific sound.
	*	@method unpauseSound
	*	@public
	*	@param {String} alias The alias of the sound to pause. 
	*		Internally, this can also be the object from the _sounds dictionary directly.
	*/
	p.unpauseSound = function(alias)
	{
		var sound;
		if(typeof alias == &quot;string&quot;)
			sound = this._sounds[alias];
		else
			sound = alias;
		var arr = sound.playing;
		for(var i = arr.length - 1; i &gt;= 0; --i)
		{
			arr[i].unpause();
		}
			
	};

	/**
	*	Pauses all sounds.
	*	@method pauseAll
	*	@public
	*/
	p.pauseAll = function()
	{
		var arr = this._sounds;
		for(var i in arr)
			this.pauseSound(arr[i]);
	};

	/**
	*	Unpauses all sounds.
	*	@method unpauseAll
	*	@public
	*/
	p.unpauseAll = function()
	{
		var arr = this._sounds;
		for(var i in arr)
			this.unpauseSound(arr[i]);
	};

	/**
	*	Sets mute status of all sounds in a context
	*	@method setContextMute
	*	@public
	*	@param {String} context The name of the context to modify.
	*	@param {bool} muted If the context should be muted.
	*/
	p.setContextMute = function(context, muted)
	{
		context = this._contexts[context];
		if(context)
		{
			context.muted = muted;
			var volume = context.volume;
			var arr = context.sounds;
			for(var i = arr.length - 1; i &gt;= 0; --i)
			{
				var s = arr[i];
				if(s.playing.length)
				{
					var playing = s.playing;
					for(var j = playing.length - 1; j &gt;= 0; --j)
					{
						playing[j].updateVolume(muted ? 0 : volume);
					}
				}
			}
		}
	};

	/**
	*	Sets volume of a context. Individual sound volumes are multiplied by this value.
	*	@method setContextVolume
	*	@public
	*	@param {String} context The name of the context to modify.
	*	@param {Number} volume The volume for the context (0 to 1).
	*/
	p.setContextVolume = function(context, volume)
	{
		context = this._contexts[context];
		if(context)
		{
			var muted = context.muted;
			context.volume = volume;
			var arr = context.sounds;
			for(var i = arr.length - 1; i &gt;= 0; --i)
			{
				var s = arr[i];
				if(s.playing.length)
				{
					var playing = s.playing;
					for(var j = playing.length - 1; j &gt;= 0; --j)
					{
						playing[j].updateVolume(muted ? 0 : volume);
					}
				}
			}
		}
	};
	
	/**
	*	Preloads a specific sound.
	*	@method preloadSound
	*	@public
	*	@param {String} alias The alias of the sound to load.
	*	@param {function} callback The function to call when the sound is finished loading.
	*/
	p.preloadSound = function(alias, callback)
	{
		var sound = this._sounds[alias];
		if(!sound)
		{
			Debug.error(&quot;Sound does not exist: &quot; + alias + &quot; - can&#x27;t preload!&quot;);
			return;
		}
		if(sound.state != UNLOADED) return;
		sound.state = LOADING;
		sound.preloadCallback = callback || null;
		MediaLoader.instance.load(
			sound.src, //url to load
			this._markLoaded,//complete callback
			null,//progress callback
			0,//priority
			sound//the sound object (contains properties for PreloadJS/SoundJS)
		);
	};

	/**
	*	Preloads a list of sounds.
	*	@method preload
	*	@public
	*	@param {Array} list An array of sound aliases to load.
	*	@param {function} callback The function to call when all sounds have been loaded.
	*/
	p.preload = function(list, callback)
	{
		if(!list || list.length === 0)
		{
			if(callback)
				callback();
			return;
		}

		var tasks = [];
		for(var i = 0, len = list.length; i &lt; len; ++i)
		{
			var sound = this._sounds[list[i]];
			if(sound)
			{
				if(sound.state == UNLOADED)
				{
					sound.state = LOADING;
					//sound is passed last so that SoundJS gets the sound ID
					tasks.push(new LoadTask(sound.id, sound.src, this._markLoaded, null, 0, sound));
				}
			}
			else
			{
				Debug.error(&quot;cloudkid.Sound was asked to preload &quot; + list[i] + &quot; but it is not a registered sound!&quot;);
			}
		}
		if(tasks.length &gt; 0)
		{
			TaskManager.process(tasks, function()
			{
				if(callback)
					callback();
			});
		}
		else if(callback)
		{
			callback();
		}
	};
	
	/**
	*	Marks a sound as loaded. If it needs to play after the load, then it is played.
	*	@method _markLoaded
	*	@private
	*	@param {String} alias The alias of the sound to mark.
	*	@param {function} callback A function to call to show that the sound is loaded.
	*/
	p._markLoaded = function(result)
	{
		var alias = result.id;
		var sound = this._sounds[alias];
		if(sound)
		{
			sound.state = LOADED;
			if(sound.playAfterLoad)
				this._playAfterLoad(alias);
		}
		var callback = sound.preloadCallback;
		if(callback)
		{
			sound.preloadCallback = null;
			callback();
		}
	};
	
	/**
	*	Creates a Task for the CloudKid Task library for preloading a list of sounds.
	*	@method createPreloadTask
	*	@public
	*	@param {String} id The id of the task.
	*	@param {Array} list An array of sound aliases to load.
	*	@param {function} callback The function to call when the task is complete.
	*/
	p.createPreloadTask = function(id, list, callback)
	{
		return new SoundListTask(id, list, callback);
	};
	
	/**
	*	Unloads a list of sounds to reclaim memory if possible. 
	*	If the sounds are playing, they are stopped.
	*	@method unload
	*	@public
	*	@param {Array} list An array of sound aliases to unload.
	*/
	p.unload = function(list)
	{
		if(!list) return;
		
		for(var i = 0, len = list.length; i &lt; len; ++i)
		{
			var sound = this._sounds[list[i]];
			if(sound)
			{
				this._stopSound(sound);
				sound.state = UNLOADED;
			}
			createjs.Sound.removeSound(list[i]);
		}
	};

	/**
	*	Places a SoundInst back in the pool for reuse.
	*	@method _poolinst
	*	@private
	*	@param {SoundInst} inst The instance to repool.
	*/
	p._poolInst = function(inst)
	{
		inst._endCallback = null;
		inst.alias = null;
		inst._channel = null;
		inst._startFunc = null;
		inst.curVol = 0;
		inst.paused = false;
		inst.isValid = false;
		this._pool.push(inst);
	};
	
	/**
	*	Destroys cloudkid.Sound. This does not unload loaded sounds, destroy SoundJS to do that.
	*	@method destroy
	*	@public
	*/
	p.destroy = function()
	{
		_instance = null;
		this._volumes = null;
		this._fades = null;
		this._contexts = null;
		this._pool = null;
	};
	
	/**
	*  A playing instance of a sound (or promise to play as soon as it loads). These can only
	*  be created through cloudkid.Sound.instance.play().
	*  @class SoundInst
	*/
	var SoundInst = function()
	{
		/**
		*	SoundJS SoundInstance, essentially a sound channel.
		*	@property {createjs.SoundInstance} _channel
		*	@private
		*/
		this._channel = null;
		/**
		*	Internal callback function for when the sound ends.
		*	@property {function} _endFunc
		*	@private
		*/
		this._endFunc = null;
		/**
		*	User&#x27;s callback function for when the sound ends.
		*	@property {function} _endCallback
		*	@private
		*/
		this._endCallback = null;
		/**
		*	User&#x27;s callback function for when the sound starts. This is only used if the sound wasn&#x27;t loaded before play() was called.
		*	@property {function} _startFunc
		*	@private
		*/
		this._startFunc = null;
		/**
		*	An array of relevant parameters passed to play(). This is only used if the sound wasn&#x27;t loaded before play() was called.
		*	@property {Array} _startParams
		*	@private
		*/
		this._startParams = null;
		/**
		*	The alias for the sound that this instance was created from.
		*	@property {String} alias
		*	@public
		*	@readOnly
		*/
		this.alias = null;
		/**
		*	The current time in milliseconds for the fade that this sound instance is performing.
		*	@property {Number} _fTime
		*	@private
		*/
		this._fTime = 0;
		/**
		*	The duration in milliseconds for the fade that this sound instance is performing.
		*	@property {Number} _fDur
		*	@private
		*/
		this._fDur = 0;
		/**
		*	The starting volume for the fade that this sound instance is performing.
		*	@property {Number} _fEnd
		*	@private
		*/
		this._fStart = 0;
		/**
		*	The ending volume for the fade that this sound instance is performing.
		*	@property {Number} _fEnd
		*	@private
		*/
		this._fEnd = 0;
		/**
		*	The current sound volume (0 to 1). This is multiplied by the sound context&#x27;s volume.
		*	Setting this won&#x27;t take effect until updateVolume() is called.
		*	@property {Number} curVol
		*	@public
		*/
		this.curVol = 0;
		/**
		*	The length of the sound in milliseconds. This is 0 if it hasn&#x27;t finished loading.
		*	@property {Number} length
		*	@public
		*/
		this.length = 0;
		/**
		*	If the sound is currently paused. Setting this has no effect - use pause() and unpause().
		*	@property {bool} paused
		*	@public
		*	@readOnly
		*/
		this.paused = false;
		/**
		*	An active SoundInst should always be valid. This is primarily for compatability with cloudkid.Audio.
		*	@property {bool} isValid
		*	@public
		*	@readOnly
		*/
		this.isValid = true;
	};
	
	/**
	*	The position of the sound playhead in milliseconds, or 0 if it hasn&#x27;t started playing yet.
	*	@property {Number} position
	*	@public
	*/
	Object.defineProperty(SoundInst.prototype, &quot;position&quot;, 
	{
		get: function(){ return this._channel ? this._channel.getPosition() : 0;}
	});

	/**
	*	Stops this SoundInst.
	*	@method stop
	*	@public
	*/
	SoundInst.prototype.stop = function()
	{
		var s = Sound.instance;
		var sound = s._sounds[this.alias];
		sound.playing.splice(sound.playing.indexOf(this), 1);
		Sound.instance._stopInst(this);
	};

	/**
	*	Updates the volume of this SoundInst.
	*	@method updateVolume
	*	@public
	*	@param {Number} contextVol The volume of the sound context that the sound belongs to. If omitted, the volume is automatically collected.
	*/
	SoundInst.prototype.updateVolume = function(contextVol)
	{
		if(!this._channel) return;
		if(contextVol === undefined)
		{
			var s = Sound.instance;
			var sound = s._sounds[this.alias];
			if(sound.context)
			{
				var context = s._contexts[sound.context];
				contextVol = context.muted ? 0 : context.volume;
			}
			else
				contextVol = 1;
		}
		this._channel.setVolume(contextVol * this.curVol);
	};

	/**
	*	Pauses this SoundInst.
	*	@method pause
	*	@public
	*/
	SoundInst.prototype.pause = function()
	{
		if(this.paused) return;
		this.paused = true;
		if(!this._channel) return;
		this._channel.pause();
	};

	/**
	*	Unpauses this SoundInst.
	*	@method unpause
	*	@public
	*/
	SoundInst.prototype.unpause = function()
	{
		if(!this.paused) return;
		this.paused = false;
		if(!this._channel) return;
		this._channel.resume();
	};

	/**
	*  A task for loading a list of sounds.. These can only
	*  be created through Sound.instance.createPreloadTask().
	*  @class SoundListTask
	*  @extends {cloudkid.Task}
	*/
	var SoundListTask = function(id, list, callback)
	{
		this.initialize(id, callback);
		this.list = list;
	};

	SoundListTask.prototype = Object.create(Task.prototype);
	SoundListTask.s = Task.prototype;

	SoundListTask.prototype.start = function(callback)
	{
		_instance.preload(this.list, callback);
	};

	SoundListTask.prototype.destroy = function()
	{
		SoundListTask.s.destroy.apply(this);
		this.list = null;
	};

	/**
	*  A private class that represents a sound context.
	*  @class SoundContext
	*  @constructor
	*  @param {String} id The name of the sound context.
	*/
	var SoundContext = function(id)
	{
		/**
		*	The name of the sound context.
		*	@property {String} id
		*	@public
		*/
		this.id = id;
		/**
		*	The current volume to apply to all sounds in the context (0 to 1).
		*	@property {Number} volume
		*	@public
		*/
		this.volume = 1;
		/**
		*	If all sounds in the sound context are muted or not.
		*	@property {bool} muted
		*	@public
		*/
		this.muted = false;
		/**
		*	The sound objects in this context, from Sound.instance._sounds;
		*	@property {Array} sounds
		*	@public
		*/
		this.sounds = [];
	};

	SoundContext.prototype = {};
	
	namespace(&#x27;cloudkid&#x27;).Sound = Sound;
}());
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>